{"id": "0818cbf50fb67b4fc6ff24bc7d8ecc70703d6d3c59c23a29cedcff8b7e3d924b", "repo": "https://github.com/AlanCunningham/krpc-scripts", "commit": "c1a363faaaad84b17e19151692f930c887b2281e", "path": "demo.py", "lang": "python", "name": "launch", "description": "Extracted function launch from demo.py", "code": "def launch(connection):\n    # Setup heading, control and throttle\n    vessel = connection.space_center.active_vessel\n    vessel.auto_pilot.target_pitch_and_heading(90, 90)\n    vessel.auto_pilot.sas = True\n    vessel.control.throttle = 1\n    time.sleep(1)\n\n    # Launch\n    print(\"Launch\")\n    vessel.control.activate_next_stage()\n\n    # Thrust until half fuel is remaining, then move to the next stage\n    fuel_amount = connection.get_call(vessel.resources.amount, name=\"LiquidFuel\")\n    max_fuel_capacity = vessel.resources.max(\"LiquidFuel\")\n    monitor_fuel_expression = connection.krpc.Expression.less_than(\n        connection.krpc.Expression.call(fuel_amount),\n        connection.krpc.Expression.constant_float(10)\n    )\n    fuel_event = connection.krpc.add_event(monitor_fuel_expression)\n    with fuel_event.condition:\n        fuel_event.wait()\n    # At half fuel\n    vessel.control.throttle = 0\n    time.sleep(1)\n    vessel.control.activate_next_stage()\n\n    # Wait until 500m and deploy the parachutes\n    vessel.auto_pilot.sas = False\n    altitude = connection.get_call(getattr, vessel.flight(), \"mean_altitude\")\n    parachute_altitude = connection.krpc.Expression.less_than(\n        connection.krpc.Expression.call(altitude),\n        connection.krpc.Expression.constant_double(500)\n    )\n    altitude_event = connection.krpc.add_event(parachute_altitude)\n    with altitude_event.condition:\n        altitude_event.wait()\n    print(f\"Altitude: {vessel.flight().mean_altitude}\")\n    vessel.control.activate_next_stage()\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "", "created_at": "2025-11-01T04:58:13Z", "size_bytes": 1526, "lines_of_code": 39, "inputs": ["connection"], "restricted": false}
{"id": "723128a36fc9c309c5907ca775b243c1120b198424dc48da21d285c8b18d28a7", "repo": "https://github.com/AlanCunningham/krpc-scripts", "commit": "c1a363faaaad84b17e19151692f930c887b2281e", "path": "helpers.py", "lang": "python", "name": "get_thrust_to_weight_ratio", "description": "Gets the thrust-to-weight ratio of a given vessel.\nThrust-to-weight = Thrust / (mass * gravity) > 1\n:params conn: A krpc connection\n:params vessel: Vessel object\n:return: Thrust to weight ratio as a double", "code": "def get_thrust_to_weight_ratio(conn, vessel):\n    \"\"\"\n    Gets the thrust-to-weight ratio of a given vessel.\n    Thrust-to-weight = Thrust / (mass * gravity) > 1\n    :params conn: A krpc connection\n    :params vessel: Vessel object\n    :return: Thrust to weight ratio as a double\n    \"\"\"\n    thrust = vessel.available_thrust\n    mass = vessel.mass\n    gravity = conn.space_center.bodies[\"Kerbin\"].surface_gravity\n    ratio = thrust / (mass * gravity)\n    print(f\"Thrust: {thrust} | Mass: {mass} | Gravity: {gravity} | Ratio: {ratio}\")\n    return ratio\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "", "created_at": "2025-11-01T04:58:13Z", "size_bytes": 552, "lines_of_code": 14, "inputs": ["conn", "vessel"], "restricted": false}
{"id": "11439c561dfdcd74243327c0ee8074feb48ab795c325f482768078ed1d276b41", "repo": "https://github.com/AlanCunningham/krpc-scripts", "commit": "c1a363faaaad84b17e19151692f930c887b2281e", "path": "helpers.py", "lang": "python", "name": "get_estimated_delta_v", "description": "Gets the estimated delta-v of a given vessel. This is a rough approxmation\nand may be less accurate the larger the vessel.\nhttps://wiki.kerbalspaceprogram.com/wiki/Cheat_sheet\nΔv = Isp * g0   * ln(total_mass/dry_mass)\nFor example:\n   = 400 * 9.81 * ln(3.72/1.72)\n   = 400 * 9.81 * ln(2.16)\n   = 400 * 9.81 * 0.771 = 3026.97 m/s\n:params conn: A krpc connection\n:params vessel: Vessel object\n:params sea_level_impulse: Whether to use specific impulse at Kerbin sea-level\nor specific impulse in a vacuum.\n:returns: A float of the estimated delta v", "code": "def get_estimated_delta_v(conn, vessel, sea_level_impulse=True):\n    \"\"\"\n    Gets the estimated delta-v of a given vessel. This is a rough approxmation\n    and may be less accurate the larger the vessel.\n    https://wiki.kerbalspaceprogram.com/wiki/Cheat_sheet\n    Δv = Isp * g0   * ln(total_mass/dry_mass)\n    For example:\n       = 400 * 9.81 * ln(3.72/1.72)\n       = 400 * 9.81 * ln(2.16)\n       = 400 * 9.81 * 0.771 = 3026.97 m/s\n    :params conn: A krpc connection\n    :params vessel: Vessel object\n    :params sea_level_impulse: Whether to use specific impulse at Kerbin sea-level\n    or specific impulse in a vacuum.\n    :returns: A float of the estimated delta v\n    \"\"\"\n    print(\"Calculating delta-v\")\n    kerbin_gravity = conn.space_center.bodies[\"Kerbin\"].surface_gravity\n    number_of_stages = vessel.control.current_stage\n    sum_delta_v = 0\n    total_mass = 0\n    previous_stage_total_mass_sum = 0\n    # Iterate through each part in the stage in reverse-stage order, so we\n    # can accumulate the mass as we go.\n    for stage in range(-2, number_of_stages):\n        engine_list = []\n        stage_delta_v = 0\n        stage_total_mass_sum = 0\n        stage_dry_mass_sum = 0\n        # For each part in the current stage\n        for stage_part in vessel.parts.in_decouple_stage(stage):\n            # Accumulate the mass so far\n            stage_total_mass_sum = stage_total_mass_sum + stage_part.mass / 1000\n            stage_dry_mass_sum = stage_dry_mass_sum + stage_part.dry_mass / 1000\n            # Sum up the total mass\n            total_mass = total_mass + stage_part.mass / 1000\n            if stage_part.engine:\n                engine_list.append(stage_part)\n        # After adding up the mass for parts in the stage, work out the delta v\n        # for this stage\n        for engine_part in engine_list:\n            if sea_level_impulse:\n                engine_impulse = engine_part.engine.kerbin_sea_level_specific_impulse\n            else:\n                engine_impulse = engine_part.engine.vacuum_specific_impulse\n            stage_delta_v = (\n                engine_impulse\n                * kerbin_gravity\n                * math.log(\n                    total_mass / (stage_dry_mass_sum + previous_stage_total_mass_sum)\n                )\n            )\n        # Sum the stage's delta-v\n        sum_delta_v = sum_delta_v + stage_delta_v\n        if len(vessel.parts.in_decouple_stage(stage)):\n            previous_stage_total_mass_sum = (\n                previous_stage_total_mass_sum + stage_total_mass_sum\n            )\n    return sum_delta_v\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "", "created_at": "2025-11-01T04:58:13Z", "size_bytes": 2570, "lines_of_code": 59, "inputs": ["conn", "vessel", "sea_level_impulse"], "restricted": false}
{"id": "429fed8d971c786e5ac0e090229c99e01eb67c5d1a6b38c37545ad992fa32760", "repo": "https://github.com/AlanCunningham/krpc-scripts", "commit": "c1a363faaaad84b17e19151692f930c887b2281e", "path": "helpers.py", "lang": "python", "name": "_auto_stage_thread", "description": "Automatically activate the next stage once the current stage's fuel is\nempty. Will skip past stages that don't have fuel (e.g. separation-only\nstages)", "code": "def _auto_stage_thread(connection, vessel):\n    \"\"\"\n    Automatically activate the next stage once the current stage's fuel is\n    empty. Will skip past stages that don't have fuel (e.g. separation-only\n    stages)\n    \"\"\"\n    while auto_stage_enabled:\n        fuel_in_current_stage = vessel.resources_in_decouple_stage(\n            stage=vessel.control.current_stage - 1, cumulative=False\n        )\n        if not fuel_in_current_stage.names:\n            print(\"No fuel in this stage - moving to next stage\")\n            vessel.control.activate_next_stage()\n        else:\n            print(f\"Fuel types in this stage: {fuel_in_current_stage.names}\")\n            fuel_in_current_stage_fuel_amount = connection.add_stream(\n                fuel_in_current_stage.amount, name=fuel_in_current_stage.names[0]\n            )\n            while fuel_in_current_stage_fuel_amount() > 0.1:\n                if auto_stage_enabled:\n                    pass\n                else:\n                    break\n\n            if auto_stage_enabled:\n                print(f\"{fuel_in_current_stage.names} empty - moving to next stage\")\n                vessel.control.activate_next_stage()\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "", "created_at": "2025-11-01T04:58:13Z", "size_bytes": 1165, "lines_of_code": 27, "inputs": ["connection", "vessel"], "restricted": false}
{"id": "8f6f54db01d87f2e61f8550f238fc9f4187b3e8094b115d7867775b43618015d", "repo": "https://github.com/AlanCunningham/krpc-scripts", "commit": "c1a363faaaad84b17e19151692f930c887b2281e", "path": "helpers.py", "lang": "python", "name": "enable_auto_stage", "description": "Enable auto staging. Starts a new thread to monitor the fuel in the current\nstage, and moves to the next stage when there's no fuel.", "code": "def enable_auto_stage(connection, vessel):\n    \"\"\"\n    Enable auto staging. Starts a new thread to monitor the fuel in the current\n    stage, and moves to the next stage when there's no fuel.\n    \"\"\"\n    global auto_stage_enabled\n    auto_stage_enabled = True\n    auto_stage_thread = threading.Thread(\n        target=_auto_stage_thread,\n        args=[connection, vessel],\n    )\n    auto_stage_thread.should_abort_immediately = True\n    auto_stage_thread.start()\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "", "created_at": "2025-11-01T04:58:13Z", "size_bytes": 462, "lines_of_code": 13, "inputs": ["connection", "vessel"], "restricted": false}
{"id": "a36ef73e9779d8c65e6e75cdfeb15cae86a860fb88c05e918b00adc97804ed51", "repo": "https://github.com/AlanCunningham/krpc-scripts", "commit": "c1a363faaaad84b17e19151692f930c887b2281e", "path": "helpers.py", "lang": "python", "name": "disable_auto_stage", "description": "Stop auto staging.", "code": "def disable_auto_stage():\n    \"\"\"\n    Stop auto staging.\n    \"\"\"\n    global auto_stage_enabled\n    auto_stage_enabled = False\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "", "created_at": "2025-11-01T04:58:13Z", "size_bytes": 126, "lines_of_code": 6, "restricted": false}
{"id": "11a6312073141dd1f9af6eb2f3c151e9dee7c4fc04b40e74184f9d0ca8f0d54f", "repo": "https://github.com/AlanCunningham/krpc-scripts", "commit": "c1a363faaaad84b17e19151692f930c887b2281e", "path": "mun.py", "lang": "python", "name": "kerbin_to_mun", "description": "Takes a given vessel currently in orbit with Kerbin and moves to orbit with\nthe Mun.\n:params connection: A krpc connection\n:params vessel: A vessel object\n:parmas target_orbit_altitude: A double of the target orbit altitude", "code": "def kerbin_to_mun(connection, vessel, target_orbit_altitude):\n    \"\"\"\n    Takes a given vessel currently in orbit with Kerbin and moves to orbit with\n    the Mun.\n    :params connection: A krpc connection\n    :params vessel: A vessel object\n    :parmas target_orbit_altitude: A double of the target orbit altitude\n    \"\"\"\n    start_time = datetime.now()\n    ut = connection.add_stream(getattr, connection.space_center, \"ut\")\n\n    # Target the Mun\n    connection.space_center.target_body = connection.space_center.bodies[\"Mun\"]\n\n    # Creates a manuever node, initially at the current position. If it doesn't\n    # encounter the Mun's sphere of influence, move the node further on in the\n    # orbit. Repeat this process until the manuever encounters the Mun.\n    # For estimated delta-v, see:\n    # https://wiki.kerbalspaceprogram.com/wiki/Cheat_sheet#Maps\n    estimated_mun_encounter_delta_v = 860\n    mun_node = vessel.control.add_node(\n        connection.space_center.ut,\n        prograde=estimated_mun_encounter_delta_v,\n    )\n    universal_time_increment_counter = 100\n    time_to_soi_change = float(\"nan\")\n    while math.isnan(time_to_soi_change):\n        # Returns float \"nan\" if there is no sphere of influence change\n        time_to_soi_change = mun_node.orbit.time_to_soi_change\n        if math.isnan(time_to_soi_change):\n            # Increment counter further into the future.\n            mun_node.ut += universal_time_increment_counter\n\n    # Face the direction of the manuever mun_node\n    vessel.auto_pilot.disengage()\n    vessel.auto_pilot.sas = True\n    vessel.control.rcs = True\n    # There seems to be a race condition of some sort where SAS pilot mode\n    # gets enabled, but doesn't switch to maneuver mode. Workaround here\n    # is just to keep trying until we've switched to maneuever mode.\n    while vessel.auto_pilot.sas_mode != vessel.auto_pilot.sas_mode.maneuver:\n        time.sleep(1)\n        vessel.auto_pilot.sas_mode = vessel.auto_pilot.sas_mode.maneuver\n\n    # Warp to manuever\n    time_to_mun_manuever = connection.add_stream(getattr, mun_node, \"time_to\")\n    print(f\"Manuever in {time_to_mun_manuever()} seconds\")\n    lead_time = 45\n    connection.space_center.warp_to((ut() + time_to_mun_manuever()) - lead_time)\n\n    while time_to_mun_manuever() >= 30:\n        pass\n\n    # Start burning in the direction of the manuever mun_node\n    print(\"Starting burn for Mun\")\n    while mun_node.remaining_delta_v > 5:\n        vessel.control.throttle = 1\n\n    # Finished burn\n    print(\"Manuever complete\")\n    vessel.control.throttle = 0\n    mun_node.remove()\n    # vessel.control.rcs = False\n    # vessel.auto_pilot.sas = False\n\n    # Warp to the Mun's periapsis\n    # First warp to the SOI change\n    time_to_mun_soi_change = connection.add_stream(\n        getattr, vessel.orbit, \"time_to_soi_change\"\n    )\n    buffer_time = 10\n    connection.space_center.warp_to((ut() + time_to_mun_soi_change()) + buffer_time)\n\n    # Face retrograde\n    while vessel.auto_pilot.sas_mode != vessel.auto_pilot.sas_mode.retrograde:\n        time.sleep(1)\n        vessel.auto_pilot.sas_mode = vessel.auto_pilot.sas_mode.retrograde\n\n    # Now warp to the Mun's periapsis\n    time_to_periapsis = connection.add_stream(\n        getattr, vessel.orbit, \"time_to_periapsis\"\n    )\n    lead_time = 75\n    connection.space_center.warp_to((ut() + time_to_periapsis()) - lead_time)\n\n    while time_to_periapsis() > 60:\n        pass\n\n    # Circularise the orbit by burning retrograde.\n    # The apoapsis readings start off as a minus value, and then switch to a\n    # positive, so we do two checks here. First check for when the apoapsis\n    # switches, and then compare against the higher value.\n    periapsis = connection.add_stream(getattr, vessel.orbit, \"periapsis_altitude\")\n    apoapsis = connection.add_stream(getattr, vessel.orbit, \"apoapsis_altitude\")\n\n    while periapsis() > apoapsis() * 0.99:\n        vessel.control.throttle = 1\n\n    # Apoapsis reading has switched\n    # The throttle is based on how close we are to the periapsis - i.e. increase\n    # the throttle the closer to the periapsis we are, decrease throttle the\n    # further away we are.\n    vessel.control.throttle = 0\n    while periapsis() < apoapsis() * 0.99:\n        max_time_to_periapsis = 30\n        min_time_to_periapsis = 20\n\n        # Adjust the throttle based on how close to the periapsis we are.\n        adjusted_throttle = 1 - (time_to_periapsis() - min_time_to_periapsis) / (\n            max_time_to_periapsis - min_time_to_periapsis\n        )\n        vessel.control.throttle = adjusted_throttle\n\n    # In stable orbit\n    vessel.control.rcs = False\n    vessel.auto_pilot.sas = False\n    vessel.control.throttle = 0\n    vessel.auto_pilot.disengage()\n\n    duration = datetime.now() - start_time\n    print(f\"Orbit achieved in {duration}\")\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "", "created_at": "2025-11-01T04:58:13Z", "size_bytes": 4821, "lines_of_code": 121, "inputs": ["connection", "vessel", "target_orbit_altitude"], "restricted": false}
{"id": "790a1ed319c5d037d1b4cc57eae3ba1cbef4abe857b32126d1166eaa91b34603", "repo": "https://github.com/AlanCunningham/krpc-scripts", "commit": "c1a363faaaad84b17e19151692f930c887b2281e", "path": "orbit.py", "lang": "python", "name": "launch", "description": "Launch a given vessel into orbit at a given target altitude.\n:params connection: A krpc connection\n:params vessel: A vessel object\n:params heading: The heading of the orbit\n:params target_altitude: The target apoapsis and periapsis altitude in meters", "code": "def launch(connection, vessel, heading, target_altitude):\n    \"\"\"\n    Launch a given vessel into orbit at a given target altitude.\n    :params connection: A krpc connection\n    :params vessel: A vessel object\n    :params heading: The heading of the orbit\n    :params target_altitude: The target apoapsis and periapsis altitude in meters\n    \"\"\"\n    # Set up telemetry streams\n    altitude = connection.add_stream(getattr, vessel.flight(), \"mean_altitude\")\n    apoapsis = connection.add_stream(getattr, vessel.orbit, \"apoapsis_altitude\")\n    periapsis = connection.add_stream(getattr, vessel.orbit, \"periapsis_altitude\")\n    time_to_apoapsis = connection.add_stream(getattr, vessel.orbit, \"time_to_apoapsis\")\n\n    # Setup heading, control and throttle\n    vessel.auto_pilot.engage()\n    vessel.auto_pilot.target_pitch_and_heading(90, heading)\n    vessel.control.throttle = 1\n\n    # Countdown...\n    print(\"3...\")\n    time.sleep(1)\n    print(\"2...\")\n    time.sleep(1)\n    print(\"1...\")\n    time.sleep(1)\n    print(\"Launch!\")\n    vessel.control.activate_next_stage()\n    start_time = datetime.now()\n\n    # When fuel is empty in the current stage, automatically move to the next\n    # one\n    helpers.enable_auto_stage(connection, vessel)\n\n    running = True\n    while running:\n        # Start gravity turn - we start pointing up (90 degrees) and gradually\n        # pitch until we're at 45 degrees.\n        min_altitude = 0\n        max_altitude = 10000\n        start_pitch = 90\n        end_pitch = 45\n        if apoapsis() < target_altitude and int(vessel.auto_pilot.target_pitch) != end_pitch:\n            adjusted_pitch = start_pitch - ((altitude() - min_altitude) / (\n                max_altitude - min_altitude\n            )) * end_pitch\n\n            vessel.auto_pilot.target_pitch = adjusted_pitch\n\n        # Approaching the target apoapsis altitude\n        if apoapsis() > target_altitude * 0.9:\n            print(f\"Approaching target apoapsis: {apoapsis()} / {target_altitude}\")\n            # Get rid of the solid boosters if they're still in use, as we're\n            # approaching the apoapsis\n            fuel_in_current_stage = vessel.resources_in_decouple_stage(\n                stage=vessel.control.current_stage - 1, cumulative=False\n            )\n            if \"SolidFuel\" in fuel_in_current_stage.names:\n                vessel.control.activate_next_stage()\n                solid_fuel_separated = True\n                print(\"Near target apoapsis - separating solid fuel boosters early\")\n            break\n\n    # Reduce throttle and boost until we reach the target orbit altitude\n    vessel.control.throttle = 0.25\n    while apoapsis() < target_altitude:\n        pass\n\n    # Reached target apoapsis - shut down engines\n    print(f\"Reached target apoapsis: {apoapsis()} / {target_altitude}\")\n    vessel.control.throttle = 0\n    vessel.auto_pilot.target_pitch = 0\n\n    # Circularise the orbit.\n    starting_periapsis = periapsis()\n    max_apoapsis = apoapsis() * 0.7\n    while periapsis() < apoapsis() * 0.99:\n        max_time_to_apoapsis = 25\n        min_time_to_apoapsis = 15\n\n        if time_to_apoapsis() <= max_time_to_apoapsis:\n            # Adjust the throttle - start at full throttle and gradually reduce\n            # as the periapsis matches the apoapsis.\n            adjusted_throttle = 1 - (periapsis() - starting_periapsis) / (\n                max_apoapsis - starting_periapsis\n            )\n            if adjusted_throttle > 0.1:\n                vessel.control.throttle = adjusted_throttle\n\n\n            # Adjust pitch based on how close we are to the apoapsis - i.e., pitch\n            # up by 10 degrees if we're close to the apoapsis, and pitch down by 10\n            # degrees the further away we are.\n            # Pitching up will \"move\" the apoapsis further away, while pitching down\n            # will \"move\" the apoapsis closer to us.\n            adjusted_pitch = -10 + (1 - (time_to_apoapsis() - min_time_to_apoapsis) / (\n                max_time_to_apoapsis - min_time_to_apoapsis\n            )) * 20\n\n            vessel.auto_pilot.target_pitch = adjusted_pitch\n\n    # In stable orbit\n    vessel.control.throttle = 0\n    vessel.control.rcs = False\n    vessel.auto_pilot.disengage()\n    helpers.disable_auto_stage()\n    launch_duration = datetime.now() - start_time\n    print(f\"Stable orbit achieved in {launch_duration}\")\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "", "created_at": "2025-11-01T04:58:14Z", "size_bytes": 4359, "lines_of_code": 108, "inputs": ["connection", "vessel", "heading", "target_altitude"], "restricted": false}
{"id": "eee0df09874b4d5a5943027d6cab8404ee7bd0546bf997f3ee54a9a2711cfa0a", "repo": "https://github.com/AlanCunningham/krpc-scripts", "commit": "c1a363faaaad84b17e19151692f930c887b2281e", "path": "orbit.py", "lang": "python", "name": "CONST_BLOCK", "description": "Top-level constants: HEADING_NORTH, HEADING_EAST, HEADING_SOUTH, HEADING_WEST", "code": "HEADING_NORTH = 0\nHEADING_EAST = 90\nHEADING_SOUTH = 180\nHEADING_WEST = 270\n", "categories": ["const"], "dependencies": [], "license": "UNKNOWN", "license_url": "", "created_at": "2025-11-01T04:58:14Z", "size_bytes": 75, "lines_of_code": 4, "restricted": false}
