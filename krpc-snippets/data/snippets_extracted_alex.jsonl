{"id": "1fcfc3ca08ea31fcebc6b35e5447d732ff2d562e49a7d07df1b2d2c5319d9827", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "munTransfer.py", "lang": "python", "name": "engage", "description": "Extracted function engage from munTransfer.py", "code": "def engage(vessel, space_center, connection):\n    vessel.control.rcs = True\n    fairings = vessel.parts.fairings\n    for fairing in fairings:\n        fairing.jettison()\n    vessel.control.antennas = True  # Deploy antennas\n\n\n    destSemiMajor = space_center.bodies[\"Mun\"].orbit.semi_major_axis\n    hohmannSemiMajor = destSemiMajor / 2\n    neededPhase = 2 * math.pi * (1 / (2 * (destSemiMajor ** 3 / hohmannSemiMajor ** 3) ** (1 / 2)))\n    optimalPhaseAngle = 180 - neededPhase * 180 / math.pi  # In degrees; for mun, mun should be ahead of vessel\n\n    # Get current phase angle\n    phaseAngle = 1080  # Random default value\n    vessel.auto_pilot.engage()\n    vessel.auto_pilot.reference_frame = vessel.orbital_reference_frame\n    vessel.auto_pilot.target_direction = (0.0, 1.0, 0.0)  # Point pro-grade\n\n    angleDec = False  # Whether or not phase angle is decreasing; used to make sure mun is ahead of vessel\n    prevPhase = 0\n    while abs(phaseAngle - optimalPhaseAngle) > 1 or not angleDec:\n        bodyRadius = space_center.bodies[\"Mun\"].orbit.radius\n        vesselRadius = vessel.orbit.radius\n\n        sleep(1)\n\n        bodyPos = space_center.bodies[\"Mun\"].orbit.position_at(space_center.ut, space_center.bodies[\"Mun\"].reference_frame)\n        vesselPos = vessel.orbit.position_at(space_center.ut, space_center.bodies[\"Mun\"].reference_frame)\n\n        bodyVesselDistance = ((bodyPos[0] - vesselPos[0])**2 + (bodyPos[1] - vesselPos[1])**2 + (bodyPos[2] - vesselPos[2])**2)**(1/2)\n\n        try:\n            phaseAngle = math.acos((bodyRadius**2 + vesselRadius**2 - bodyVesselDistance**2) / (2 * bodyRadius * vesselRadius))\n        except:\n            print(\"Domain error! Cannot calculate. Standby...\")\n            continue  # Domain error\n        phaseAngle = phaseAngle * 180 / math.pi\n\n        if prevPhase - phaseAngle > 0:\n            angleDec = True\n            if abs(phaseAngle - optimalPhaseAngle) > 20:\n                space_center.rails_warp_factor = 2\n            else:\n                space_center.rails_warp_factor = 0\n        else:\n            angleDec = False\n            space_center.rails_warp_factor = 4\n\n\n        prevPhase = phaseAngle\n\n        print(\"Phase:\", phaseAngle)\n\n\n    # Use vis-viva to calculate deltaV required to raise orbit to that of the moon\n    GM = vessel.orbit.body.gravitational_parameter# Get gravitation parameter (GM) for Kerbin\n    r = vessel.orbit.radius\n    a = vessel.orbit.semi_major_axis\n\n    initialV = (GM * ((2/r) - (1/a)))**(1/2)\n\n    a = (space_center.bodies[\"Mun\"].orbit.radius + vessel.orbit.radius) / 2\n\n    finalV = (GM * ((2/r) - (1/a)))**(1/2)\n\n    deltaV = finalV - initialV\n    print(\"Maneuver Now With DeltaV:\", deltaV)\n\n    actualDeltaV = 0\n    vessel.control.throttle = 1.0\n    while(deltaV > actualDeltaV):  # Complete maneuver node with <= 2% inaccuracy\n        sleep(0.15)\n        r = vessel.orbit.radius\n        a = vessel.orbit.semi_major_axis\n        actualDeltaV = (GM * ((2/r) - (1/a)))**(1/2) - initialV\n        print(\"DeltaV so far: \", actualDeltaV, \"out of needed\", deltaV)\n    vessel.control.throttle = 0\n    vessel.auto_pilot.disengage()\n\n    print(\"We should have a mun encounter!\")\n    print()\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 3177, "lines_of_code": 82, "inputs": ["vessel", "space_center", "connection"]}
{"id": "8c45b789a873cc7a086035fb76be81371e6c0bfefc6c30e34e231df53b513ec9", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "orbitMun.py", "lang": "python", "name": "engage", "description": "Extracted function engage from orbitMun.py", "code": "def engage(vessel, space_center, connection):\n    vessel.control.rcs = True\n    vessel.control.antennas = True\n    vessel.auto_pilot.engage()\n    vessel.auto_pilot.reference_frame = vessel.surface_velocity_reference_frame\n    vessel.auto_pilot.target_direction = (0.0, -1.0, 0.0)  # Point retro-grade surface\n\n    vessel.auto_pilot.wait()  # Wait until pointing retro-grade\n    time_to_warp = vessel.orbit.time_to_periapsis\n    space_center.warp_to(space_center.ut + time_to_warp - 30)  # 30 seconds from periapsis\n\n    vessel.auto_pilot.wait()\n    print(\"Fire engine...\")\n    # Stream surface velocity\n    flight = vessel.flight(vessel.orbit.body.reference_frame)\n    surfaceSpeed = connection.add_stream(getattr, flight, 'speed')\n\n    while surfaceSpeed() > 1.0:\n        vessel.control.throttle = 1 - (0.95 / 1.01**surfaceSpeed())\n\n        error = (vessel.auto_pilot.pitch_error**2 + vessel.auto_pilot.heading_error**2)**(1/2)\n        if error > 3:\n            vessel.control.throttle = 0\n            while error > 1.2:\n                error = (vessel.auto_pilot.pitch_error ** 2 + vessel.auto_pilot.heading_error ** 2) ** (1 / 2)\n                print(\"Direction error:\", vessel.auto_pilot.error)\n                sleep(0.25)\n\n    vessel.control.throttle = 0\n    print(\"Prepared for landing...\")\n    print()", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 1309, "lines_of_code": 31, "inputs": ["vessel", "space_center", "connection"]}
{"id": "b3e7df1e3644e7100bad7ef9d63617e355806524326cb5ee9db0f9c02de80dc2", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "stageMonitor.py", "lang": "python", "name": "monitor", "description": "Extracted function monitor from stageMonitor.py", "code": "def monitor(vessel):\n    sleep(3)\n    while True:\n        resources = vessel.resources_in_decouple_stage(vessel.control.current_stage - 1, False)\n\n        solidFuel = resources.amount(\"SolidFuel\")\n        liquidFuel = resources.amount(\"LiquidFuel\")\n\n        if solidFuel == 0 and liquidFuel == 0:\n            vessel.control.activate_next_stage()  # Activates stage when fuel depleted\n            print()\n            print(\"Stage decoupled!\")\n            print()\n\n        sleep(0.2)\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 482, "lines_of_code": 15, "inputs": ["vessel"]}
{"id": "5b5b0f1667d3cd31ed91bf02d202421792f0e21fb5dde136c7a5d32f034c5a1e", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "startLanding.py", "lang": "python", "name": "entryBurn", "description": "T30 Reliant Engine: Burns 8.68 oxidizer and 7.11 fuel per second at max throttle\nTotal fuel weight is 2 tons and fuel lasts approx. 25.32 seconds\nMass lost at a rate of 0.078945 tons per second - used in calculation of force of gravity\nand subsequently work needed to land", "code": "def entryBurn(vessel, space_center):\n    \"\"\"T30 Reliant Engine: Burns 8.68 oxidizer and 7.11 fuel per second at max throttle\n    Total fuel weight is 2 tons and fuel lasts approx. 25.32 seconds\n    Mass lost at a rate of 0.078945 tons per second - used in calculation of force of gravity\n    and subsequently work needed to land\"\"\"\n\n    fuel_mass_burn_rate = 0.078945  # Full throttle\n    print(vessel.flight().terminal_velocity)\n    t.sleep(5)\n    terminal_velocity = 320\n\n    # Calculate work needed to land the vessel\n    time = 0\n    mass = vessel.mass\n    gravity_acceleration = vessel.orbit.body.surface_gravity  # Approximation but fine for heights close to the surface\n\n    f_grav = mass * gravity_acceleration  # Force of gravity acting on vessel as a function of time\n    f_thrust = vessel.available_thrust  # Force of max available thrust\n\n    f_net = f_thrust - f_grav  # Net force if object thrusts as a function of time (up defined as positive)\n\n    '''Run simulation to determine if it will land'''\n\n    t_vals = []\n    acceleration_vals = []\n\n    while vessel.available_thrust == 0:\n        pass\n    initial_ut = space_center.ut\n\n\n\n    while vessel.available_thrust > 0:\n\n        time = 0\n        mass = vessel.mass\n        gravity_acceleration = vessel.orbit.body.surface_gravity  # Approximation but fine for heights close to the surface\n\n        f_grav = mass * gravity_acceleration  # Force of gravity acting on vessel as a function of time\n        f_thrust = vessel.available_thrust  # Force of max available thrust\n\n        curr_ut = space_center.ut\n\n        f_net = f_thrust - f_grav  # Net force if object thrusts as a function of time (up defined as positive)\n\n        print(\"Force of Gravity:\\t\", f_grav)\n        print(\"Thrust:\\t\", f_thrust)\n        print(\"Net force:\\t\", f_net)\n        print(\"Acceleration:\\t\", f_net/mass)\n        print(\"Time:\\t\", curr_ut-initial_ut)\n        print(\"Mass:\\t\", mass)\n        print()\n\n        #t_vals.append(curr_ut - initial_ut)\n        #acceleration_vals.append(f_net/mass)\n\n        #t.sleep(0.02)\n\n    '''with open(\"acceleration.csv\", 'w+') as file:\n        for i in range(len(t_vals)):\n            line = str(t_vals[i]) + \",\" + str(acceleration_vals[i]) + \"\\n\"\n            file.write(line)'''\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 2255, "lines_of_code": 62, "inputs": ["vessel", "space_center"]}
{"id": "1dad763abdaf447ac3dac0171024015c3464e3e576da82d7df2aee7a6034844c", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "startLanding.py", "lang": "python", "name": "begin_landing", "description": "Extracted function begin_landing from startLanding.py", "code": "def begin_landing(vessel, space_center, connection):\n    deployed = False\n    hybrid_frame = space_center.ReferenceFrame.create_hybrid(vessel.reference_frame, rotation=vessel.orbit.body.non_rotating_reference_frame)\n    #height_prediction = connection.drawing.add_text(\"Height Prediction: Null\", hybrid_frame, (-2,0,0), (1.57,3.14,3.14,0))\n    #time_prediction = connection.drawing.add_text(\"Time Prediction: Null\", hybrid_frame, (-1,0,2),(1.57,3.14,3.14,0))\n    #velocity_prediction = connection.drawing.add_text(\"Velocity Prediction: Null\", hybrid_frame, (-3,0,2), (1.57,3.14,3.14,0))\n    # Start of script\n    # TODO: Provide very slight corrections to cancel all horizontal velocity/add guidance\n\n    # Get current body\n    current_body = vessel.orbit.body\n\n    landing_reference_frame = space_center.ReferenceFrame.create_hybrid(\n        position=current_body.reference_frame, rotation=vessel.surface_reference_frame)\n    flight = vessel.flight(landing_reference_frame)\n\n    while True:\n        # Finds initial time to begin burn\n        #print(\"Mass\", vessel.mass)\n        time = velocity_intercept(vessel, -flight.velocity[0])\n        #print(\"Initial height:\", flight.surface_altitude)\n        height = height_intercept(vessel, time, -flight.velocity[0], flight.surface_altitude)\n        print(\"Predicted final height:\", height, \"with \", time, \"second burn\")\n        temp = \"Height Prediction: \" + str(height)\n        #height_prediction.content = temp\n        temp = \"Time Prediction: \" + str(time)\n        #time_prediction.content = temp\n\n        if height < 1000 and time < 9 and not deployed:\n            deployed = True\n            vessel.control.legs = True\n\n        if height < 8:\n            break\n\n    # Fire engine at max throttle\n    initial_time_prediction = time\n    print(\"FIRING ENGINE\")\n    vessel.control.throttle = 1\n    t.sleep(0.1)\n    initial_time = space_center.ut\n    new_time = time\n    # Run calculations in an attempt to keep vessel on track for landing\n    #while abs(flight.surface_altitude) > 700:\n    #    pass\n    while abs(flight.velocity[0]) > 1:\n\n        if flight.surface_altitude < 30:\n            print(\"Disengaging autopilot for final touchdown...\")\n            #vessel.auto_pilot.reference_frame = vessel.surface_reference_frame\n            #vessel.auto_pilot.engage()\n            #vessel.auto_pilot.target_pitch_and_heading(90, 90)\n            vessel.auto_pilot.disengage()\n\n        time = velocity_intercept(vessel, -flight.velocity[0], 0.01, vessel.control.throttle)\n        height = height_intercept(vessel, time, -flight.velocity[0], flight.surface_altitude, vessel.control.throttle)\n        temp = \"Height Prediction: \" + str(height)\n        #height_prediction.content = temp\n        temp = \"Time Prediction: \" + str(time)\n        #time_prediction.content = temp\n\n        if height > 3.5:\n            vessel.control.throttle -= 0.005\n        elif height < 0.5:\n            vessel.control.throttle += 0.004\n\n        if time < 9 and not deployed:\n            print(\"Deploying landing legs...\")\n            deployed = True\n            vessel.control.legs = True\n\n    vessel.auto_pilot.engage()\n    vessel.auto_pilot.target_pitch_and_heading(90, 90)  # Attempt to make rocket stand up straight\n    vessel.control.throttle = 0\n    print(\"Time to burn:\", space_center.ut - initial_time)\n    print(\"Expected:\", initial_time_prediction)\n    print()\n    print(\"Final height:\", flight.surface_altitude)\n    print(\"Landed! Exiting...\")\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 3476, "lines_of_code": 79, "inputs": ["vessel", "space_center", "connection"]}
{"id": "43d135a3b4e5a8d81fd6cb27746dd8def85598a49b8f628b443290247385d425", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "startLanding.py", "lang": "python", "name": "velocity_intercept", "description": "Finds how long it will take for velocity to equal zero\nOnly considers times between 0 and 92 seconds", "code": "def velocity_intercept(vessel, initial_velocity, tolerance=0.01, thrust_multiplier=1):\n    \"\"\"Finds how long it will take for velocity to equal zero\n    Only considers times between 0 and 92 seconds\"\"\"\n    current_body = vessel.orbit.body\n    initial_t = t.time()\n    if initial_velocity > 0:\n        initial_velocity *= -1\n    time = 10\n    thrust = thrust_multiplier * determine_surface_isp_ratio(current_body, vessel.flight(current_body.reference_frame), vessel.parts.engines) * (vessel.max_vacuum_thrust/1000)\n    # TODO: Adjust for current direction of vessel (not needed for nearly vertical entry)\n    # Adjust for direction of retrograde\n    direction = vessel.flight(vessel.surface_reference_frame).direction\n    #print(direction)\n    multiplier = direction[0] #abs(direction[1] / (direction[0] ** 2 + direction[1] ** 2 + direction[2] ** 2) ** 0.5)\n    #print(\"Multiplier:\", multiplier)\n    thrust = thrust * abs(multiplier)\n\n    gravity_accel = current_body.surface_gravity\n    mass = vessel.mass/1000\n    mass_burn_rate = approximate_mass_burn_rate(vessel)\n\n    velocity = 1\n\n    # Perform binary search on velocity function to find time to burn\n    upper_bound = 92\n    lower_bound = 0\n    num_iterations = 0\n    while abs(velocity) > tolerance and time > 0.0001 and time < 91.99:\n        velocity = (-thrust / mass_burn_rate) * log(mass - mass_burn_rate * time) \\\n                   - gravity_accel * time + initial_velocity + (thrust / mass_burn_rate) * log(mass)\n\n        num_iterations += 1\n\n        if velocity < 0:\n            lower_bound = time\n            time = (time + upper_bound) / 2\n        elif velocity > 0:\n            upper_bound = time\n            time = (time + lower_bound) / 2\n\n    if num_iterations == 0:\n        print(\"Big issues!\")  # we don't have issues anymore, redundant\n        print(velocity)\n        print(time)\n        print(thrust_multiplier)\n        print()\n    return time\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 1919, "lines_of_code": 47, "inputs": ["vessel", "initial_velocity", "tolerance", "thrust_multiplier"]}
{"id": "74c96acfb9923c1a6d7dfa03101b178ac7671acaae81645324217b386e561e1a", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "startLanding.py", "lang": "python", "name": "height_intercept", "description": "Gets the predicted final height of the vessel if the burn began now and ran for 'time' seconds", "code": "def height_intercept(vessel, time, initial_velocity, current_height, thrust_multiplier = 1):\n    \"\"\"Gets the predicted final height of the vessel if the burn began now and ran for 'time' seconds\"\"\"\n    current_body = vessel.orbit.body\n\n    thrust = thrust_multiplier * determine_surface_isp_ratio(current_body, vessel.flight(current_body.reference_frame), vessel.parts.engines) * (vessel.max_vacuum_thrust/1000)\n\n    # Adjust for direction of retrograde\n    direction = vessel.flight(vessel.surface_reference_frame).direction\n    multiplier = direction[0]\n    #print(\"Multiplier:\", multiplier)\n    thrust = thrust * abs(multiplier)\n\n    gravity_accel = current_body.surface_gravity\n    mass = vessel.mass/1000\n    mass_burn_rate = approximate_mass_burn_rate(vessel)\n\n    if initial_velocity > 0:\n        initial_velocity *= -1\n\n    final_height = (-1 / mass_burn_rate**2) * (\n        mass_burn_rate * initial_velocity * (mass - mass_burn_rate * time) + thrust * log(mass) * (mass - mass_burn_rate * time)\n        + gravity_accel * (((mass - mass_burn_rate * time)**2) / 2 - mass * (mass - mass_burn_rate * time))\n        - thrust * (mass * log(mass - mass_burn_rate * time) - mass_burn_rate * time * log(mass - mass_burn_rate * time) - mass + mass_burn_rate * time)\n    ) + current_height + (1/mass_burn_rate**2) * (\n        mass_burn_rate * initial_velocity * mass + thrust * log(mass) * mass\n        + gravity_accel * ((mass**2) / 2 - mass**2)\n        - thrust * (mass * log(mass) - mass)\n    )\n\n    return final_height\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 1522, "lines_of_code": 30, "inputs": ["vessel", "time", "initial_velocity", "current_height", "thrust_multiplier"]}
{"id": "ad73e124fd9cb137d53bd01f437219f6a812d875b71db7f25733d716e95ebcc7", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "startLanding.py", "lang": "python", "name": "velocity_function", "description": "velocity function as function of time", "code": "def velocity_function(vessel, initial_velocity, time, thrust):\n    \"\"\"velocity function as function of time\"\"\"\n    current_body = vessel.orbit.body\n\n    if initial_velocity > 0:\n        initial_velocity *= -1\n\n    gravity_accel = current_body.surface_gravity\n    mass = vessel.mass/1000\n    mass_burn_rate = approximate_mass_burn_rate(vessel)\n    try:\n        velocity = (-thrust / mass_burn_rate) * log(mass - mass_burn_rate * time) \\\n                   - gravity_accel * time + initial_velocity + (thrust / mass_burn_rate) * log(mass)\n    except:\n        velocity = 0\n    return velocity\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 590, "lines_of_code": 16, "inputs": ["vessel", "initial_velocity", "time", "thrust"]}
{"id": "1e43a3d63b1c91308fefc2270eefb5a2b56195557eccb8e3c4c97490fd50995a", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "startLanding.py", "lang": "python", "name": "height_function", "description": "height function as a function of time", "code": "def height_function(vessel, time, initial_velocity, current_height, thrust):\n    \"\"\"height function as a function of time\"\"\"\n    current_body = vessel.orbit.body\n\n    gravity_accel = current_body.surface_gravity\n    mass = vessel.mass / 1000\n    mass_burn_rate = approximate_mass_burn_rate(vessel)\n\n    if initial_velocity > 0:\n        initial_velocity *= -1\n\n    final_height = (-1 / mass_burn_rate ** 2) * (\n            mass_burn_rate * initial_velocity * (mass - mass_burn_rate * time) + thrust * log(mass) * (\n                mass - mass_burn_rate * time)\n            + gravity_accel * (((mass - mass_burn_rate * time) ** 2) / 2 - mass * (mass - mass_burn_rate * time))\n            - thrust * (mass * log(mass - mass_burn_rate * time) - mass_burn_rate * time * log(\n        mass - mass_burn_rate * time) - mass + mass_burn_rate * time)\n    ) + current_height + (1 / mass_burn_rate ** 2) * (\n                           mass_burn_rate * initial_velocity * mass + thrust * log(mass) * mass\n                           + gravity_accel * ((mass ** 2) / 2 - mass ** 2)\n                           - thrust * (mass * log(mass) - mass)\n                   )\n    #print(\"Height: \", final_height)\n    return final_height\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 1212, "lines_of_code": 24, "inputs": ["vessel", "time", "initial_velocity", "current_height", "thrust"]}
{"id": "1d030a1261eeab1d713ecc24ca20488e1e043ab9f93e241dc73f4fd674a895a0", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "startLanding.py", "lang": "python", "name": "approximate_mass_burn_rate", "description": "how fast the vessel burns mass\nonly calculates for reliant, terrier, and swivel engines currently", "code": "def approximate_mass_burn_rate(vessel):\n    \"\"\"how fast the vessel burns mass\n    only calculates for reliant, terrier, and swivel engines currently\"\"\"\n    mass_burn_rate = 0\n\n    engines = vessel.parts.engines\n    for engine in engines:\n        if engine.active or engine.available_thrust > 0:\n            if engine.part.name == \"liquidEngine\":\n                # Reliant Engine\n                mass_burn_rate += 0.078926\n            elif engine.part.name == \"liquidEngine3.v2\" or engine.part.name == \"liquidEngine3\":\n                # Terrier Engine\n                mass_burn_rate += 0.017734\n            elif engine.part.name == \"liquidEngine2\":\n                # Swivel Engine\n                mass_burn_rate += 0.068512\n    return mass_burn_rate\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 749, "lines_of_code": 18, "inputs": ["vessel"]}
{"id": "a13dad05d0b51f29364e3d1769bf1ea6daf951ddad745610f1a6fb57bb97d286", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "startLanding.py", "lang": "python", "name": "determine_surface_isp_ratio", "description": "Determines ratio of specific impulse at surface level to specific impulse in a vacuum for active engines", "code": "def determine_surface_isp_ratio(body, flight, engines):\n    \"\"\"Determines ratio of specific impulse at surface level to specific impulse in a vacuum for active engines\"\"\"\n\n    engine = None\n    isp = 0\n    for e in engines:\n        if e.active or e.available_thrust > 0:\n            engine = e\n\n    # Uses up to sixth order polynomial to approximate isp as function of pressure (very good approximation in most cases)\n    if body.has_atmosphere:\n        pressure = body.pressure_at(0) / 101325  # Convert from pascals to atm\n        if engine.part.name == \"liquidEngine\":\n            # Reliant Engine\n            isp = 0  # TODO: Find approximate isp function experimentally\n        elif engine.part.name == \"liquidEngine3.v2\" or engine.part.name == \"liquidEngine3\":\n            # Terrier Engine\n            if pressure < 3:\n                isp = -1.8606 * pressure**6 + 25.868 * pressure**5 - 133.61 * pressure**4 + 300.47 * pressure**3 - 202.47 * pressure**2 - 246.61 * pressure + 344.87\n            else:\n                isp = 0\n\n        elif engine.part.name == \"liquidEngine2\":\n            # Swivel Engine\n            isp = -0.8236 * pressure**3 + 8.534 * pressure**2 - 77.194 * pressure + 320.14\n\n        return isp / engine.vacuum_specific_impulse  # No wiggle room needed because of drag\n    else:\n        return 0.99  # Will get vacuum isp with no atmosphere, so ratio is 1 (0.99 to give a little wiggle room on landing)", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 1429, "lines_of_code": 29, "inputs": ["body", "flight", "engines"]}
{"id": "682c87e2cf0366c3dde39737bd8d7447aa4ec0a00b954b5fc6447ab8c652c003", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "targetLandingSite.py", "lang": "python", "name": "predict_impact_coordinates", "description": "# Predict landing trajectory", "code": "def predict_impact_coordinates(connection, spacecenter, vessel, flight):\n    acceleration = vessel.orbit.body.surface_gravity\n    velocity0_z, velocity0_y, velocity0_x = flight.velocity\n    height0 = flight.surface_altitude\n    lat0 = flight.latitude\n    long0 = flight.longitude\n\n    # Determines difference between current latitude, longitude and the impact latitude, longitude\n    # Uses trigonometry (factoring in height of vessel, etc)\n\n    #TEST: Draw vector to launch pad\n    print(lat0, long0)\n    a = flight.elevation - flight.surface_altitude + vessel.orbit.body.equatorial_radius\n    b = vessel.orbit.body.surface_height(-0.09716857406266075, -74.55768875892863) + vessel.orbit.body.equatorial_radius\n\n    height_difference = vessel.orbit.body.surface_height(-0.09716857406266075, -74.55768875892863) - flight.elevation + flight.surface_altitude\n    latitude_difference = (flight.latitude - (-0.09716857406266075)) * math.pi / 180\n    longitude_difference = (flight.longitude - (-74.55768875892863)) * math.pi / 180\n\n    north_distance = (a**2 + b**2 - 2*a*b*math.cos(latitude_difference))**(1/2)\n    east_distance = (a**2 + b**2 - 2*a*b*math.cos(longitude_difference))**(1/2)\n\n    print(east_distance)\n    print(north_distance)\n    print(height_difference)\n    to_launch_pad = connection.drawing.add_line((0,0,0), (height_difference-height_difference, -north_distance, -east_distance), vessel.surface_reference_frame)\n    to_launch_pad.thickness = 3\n\n    while True:\n        a = -flight.elevation + vessel.orbit.body.equatorial_radius\n        b = -vessel.orbit.body.surface_height(-0.09716857406266075,\n                                             -74.55768875892863) + vessel.orbit.body.equatorial_radius\n\n        height_difference = vessel.orbit.body.surface_height(-0.09716857406266075, -74.55768875892863) - flight.elevation - flight.surface_altitude\n        latitude_difference = (flight.latitude - (-0.09716857406266075)) * math.pi / 180\n        longitude_difference = (flight.longitude - (-74.55768875892863)) * math.pi / 180\n\n        #If the vessel is over the sea\n        if flight.elevation < 0:\n            height_difference += flight.elevation\n\n        north_distance = (a ** 2 + b ** 2 - 2 * a * b * math.cos(latitude_difference)) ** (1 / 2)\n        east_distance = (a ** 2 + b ** 2 - 2 * a * b * math.cos(longitude_difference)) ** (1 / 2)\n\n        if latitude_difference > 0:\n            north_distance *= -1\n        if longitude_difference > 0:\n            east_distance *= -1\n        if height_difference > 0:\n            height_difference += 8\n        else:\n            height_difference += 8\n        print(vessel.orbit.body.surface_height(-0.09716857406266075, -74.55768875892863))\n        print(-flight.elevation)\n        print(-flight.surface_altitude)\n        print(to_launch_pad.end)\n        print()\n        to_launch_pad.end = (height_difference, north_distance, east_distance)\n        time.sleep(0.01)\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 2938, "lines_of_code": 59, "inputs": ["connection", "spacecenter", "vessel", "flight"]}
{"id": "aceb905074a620ccfe30b3557527029b4087df56cab76f34cfab8ddea529d6b4", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "testingTools.py", "lang": "python", "name": "determine_mass_burn_rate", "description": "Extracted function determine_mass_burn_rate from testingTools.py", "code": "def determine_mass_burn_rate(space_center, vessel):\n    times = []\n    masses = []\n    initial_time = space_center.ut\n    print(\"Started.\")\n    while vessel.thrust > 0:\n        times.append(space_center.ut - initial_time)\n        masses.append(vessel.mass)\n        t.sleep(0.05)\n        print(\"Thrust:\", vessel.thrust)\n\n    # Write to csv\n    filename = vessel.parts.engines[0].part.name + \"_burn_rate.csv\"\n    with open(filename, 'w+') as file:\n        for i in range(len(times)):\n            line = str(times[i]) + \",\" + str(masses[i]) + \"\\n\"\n            file.write(line)\n            print(\"Line\", i, \"written.\")\n    print(\"Mass burn rate determined. Use produced csv.\")\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 673, "lines_of_code": 19, "inputs": ["space_center", "vessel"]}
{"id": "60ad1af216842e86d4af2bad55432982b2a9028e50418d376516216a58818e51", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "testingTools.py", "lang": "python", "name": "isp_vs_pressure", "description": "Extracted function isp_vs_pressure from testingTools.py", "code": "def isp_vs_pressure(space_center, vessel, flight):\n\n    current_body = vessel.orbit.body\n    atmospheric_pressures = []\n    isps = []\n\n    # Get the engine to investigate\n    engine = vessel.parts.engines[0]\n    engine_name = engine.part.name\n    vessel.control.throttle = 0.01\n    while len(vessel.parts.engines) > 0:\n        atmospheric_pressures.append(current_body.pressure_at(flight.mean_altitude))\n        isps.append(engine.specific_impulse)\n        t.sleep(0.02)\n    vessel.control.throttle = 0\n\n    filename = engine_name + \"_isp_vs_pressure\"\n    with open(filename, 'w+') as file:\n        for i in range(len(isps)):\n            line = str(atmospheric_pressures[i]) + \",\" + str(isps[i]) + \"\\n\"\n            file.write(line)\n    print(\"ISP curve created successfully for\", engine_name)\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 793, "lines_of_code": 22, "inputs": ["space_center", "vessel", "flight"]}
{"id": "cc6cd8a7b23e04deb41e7723512be5583be035df82224d4dcb6deb56c4bf932e", "repo": "https://github.com/alexlabbane/kRPC-mun-mission", "commit": "b4d08523742b9dbc82d9f072d32bf4da97838a62", "path": "toLKO.py", "lang": "python", "name": "engage", "description": "Sends vessel to orbit 75 x 70km in prep for transfer burn", "code": "def engage(vessel, space_center, connection, ascentProfileConstant=1.25):\n    \"\"\"Sends vessel to orbit 75 x 70km in prep for transfer burn\"\"\"\n    vessel.control.rcs = True\n\n    vessel.control.throttle = 1\n\n    apoapsisStream = connection.add_stream(getattr, vessel.orbit, 'apoapsis_altitude')\n\n    vessel.auto_pilot.engage()\n    vessel.auto_pilot.target_heading = 90\n\n    # Get to proper apoapsis/complete gravity turn\n    while apoapsisStream() < 75000:\n        # Collect values\n        targetPitch = 90 - ((90/(75000**ascentProfileConstant))*(apoapsisStream()**ascentProfileConstant))\n        print(\"Current target pitch:\", targetPitch, \"with apoapsis\", apoapsisStream())\n\n        # Set autopilot\n        vessel.auto_pilot.target_pitch = targetPitch\n\n        sleep(0.1)\n\n    vessel.control.throttle = 0\n    timeToApoapsisStream = connection.add_stream(getattr, vessel.orbit, 'time_to_apoapsis')\n    periapsisStream = connection.add_stream(getattr, vessel.orbit, 'periapsis_altitude')\n    # Now, wait and perform circularization burn\n    while(timeToApoapsisStream() > 22):\n        if(timeToApoapsisStream() > 60):\n            space_center.rails_warp_factor = 4\n        else:\n            space_center.rails_warp_factor = 0\n\n        sleep(0.5)\n\n    vessel.control.throttle = 0.5\n    lastUT = space_center.ut\n    lastTimeToAp = timeToApoapsisStream()\n    while(periapsisStream() < 70500):\n        sleep(0.2)\n        timeToAp = timeToApoapsisStream()\n        UT = space_center.ut\n        deltaTimeToAp = (timeToAp - lastTimeToAp) / (space_center.ut - lastUT)\n\n        print(\"Estimated change in time to apoapsis per second:\", deltaTimeToAp)\n\n        if deltaTimeToAp < -0.3:\n            vessel.control.throttle += 0.03\n        elif deltaTimeToAp < -0.1:\n            vessel.control.throttle += 0.01\n\n        if deltaTimeToAp > 0.2:\n            vessel.control.throttle -= 0.03\n        elif deltaTimeToAp > 0:\n            vessel.control.throttle -= 0.01\n\n        lastTimeToAp = timeToApoapsisStream()\n        lastUT = space_center.ut\n\n    vessel.control.throttle = 0\n    print(\"Apoapsis: \", apoapsisStream())\n    print(\"Periapsis: \", periapsisStream())\n    print(\"Orbit achieved!\")\n    print()\n", "categories": ["function"], "dependencies": [], "license": "UNKNOWN", "license_url": "about:blank", "created_at": "2025-11-01T05:00:48Z", "size_bytes": 2189, "lines_of_code": 63, "inputs": ["vessel", "space_center", "connection", "ascentProfileConstant"]}
